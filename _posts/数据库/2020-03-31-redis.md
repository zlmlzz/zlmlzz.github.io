---
layout: post
title: redis
category: 数据库
tags: redis
keywords: redis;数据库
--- 
## NoSql
* Not Only Sql
* 水平(横向)扩展方便高效
* 数据达到300w考虑，正常4到500w，优化6到700w
* 高性能读取(reids每秒达到10w次)
* 高可用(搭建集群)
* 存数据，做缓存
* 常见类型
    * 键值对数据库(Redis、Memcache)
    * 列存储数据库(Hbase、Cassandra)
    * 文档型数据库(MangoDB、CouchDB)
    * 图形数据库(Neo4J、FlockDB)

## 分布式缓存
* 提升读取性能
* 分布式计算领域
* 为数据库降低查询压力
* 跨服务器缓存
* 内存式缓存

## 缓存方案对比
* Ehcache
    * 优点
        * 基于java开发
        * 基于JVM缓存
        * 简单、轻巧、方便
    * 缺点
        * 集群不支持
        * 分布式不支持
* Memcache
    * 优点
        * 简单的key-value存储
        * 内存使用率比较高
        * 多核处理，多线程
    * 缺点
        * 无法容灾
        * 无法持久化
* Redis
    * 优点
        * 丰富的数据结构
        * 持久化
        * 主从同步、故障转移
        * 内存数据库
    * 缺点
        * 单线程
        * 单核

## Redis简介  
* NoSql
* 分布式缓存中间件
* key-value存储
* 提供海量数据存储访问
* 数据存储在内存里，读取更快
* 非关系型、分布式、开源、水平扩展
* Redis-REmote DIctionary Server
* Redis是一个使用ANSI C语言编写的开源数据库
* 高性能的key-value数据库
* 内存数据库,支持数据持久化   

## 为什么Redis能这么快
* 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高
* 数据结构简单，对数据操作也简单
* 采用单线程，单线程也能处理高并发请求，想多核也可启动多实例
* 使用多路I/O复用模型，非阻塞IO
    * Redis采用的I/O多路复用函数：epoll/kqueue/evport/select
    * 因地制宜
    * 优先选择时间复杂度为O(1)的I/O多路复用函数作为底层实现
    * 以时间复杂度为O(n)的select作为保底
    * 基于react设计模式监听I/O事件

## Redis安装
1. 安装gcc编译环境```yum install gcc-c++```
2. `make && make install`
3. 设置redis开机自启
```
cd utils/
cp redis_init_script /etc/init.d
vim /etc/init.d/redis_init_script
#chkconfig 22345 10 90
#description: Start and Stop Redis
chkconfig redis_init_script on
```

## Redis对象结构
* 数据类型(type)
    * string
    * hash
    * list
    * set
    * sorted set
* 编码方式
    * raw
    * int
    * ht
    * zipmap
    * linkedlist
    * ziplist
    * intset
* 数据指针
* 虚拟内存
* 其它信息

## Redis数据结构
* string
    * setex(并设置过期时间,单位秒)
    * psetex(设置过期时间,单位毫秒)
    * getrange word 0 2(取word键的值的0~2数据)
    * getset(先get后set)
    * mset(设置多个key)
    * mget
    * setnx(只有key不存在才能设置成功)
    * strlen(字符串长度)
    * msetnx(要么都成功,要么都失败;原子性)
    * incr(数字加1)
    * incrby(可自定义步长)
    * decr(数字减1)
    * decrby
    * append(追加)
* hash
    * hset
    * hexists(hash是否存在某个键)
    * hget
    * hgetall
    * hkeys
    * hvals
    * hlen
    * hmget
    * hmset
    * hdel
    * hsetnx
* list(可重复)
    * lpush(放到最前面)
    * llen
    * lrange
    * lset
    * lindex
    * lpop(移除第一个元素)
    * rpop(移除最后一个元素)
* set
    * sadd
    * scard(返回元素数量)
    * smembers(查看所有元素成员)
    * sdiff(差集)
    * sinter(交集)
    * sunion(并集)
    * srandmember(返回指定个数的随机元素)
    * sismember(是否存在元素)
    * srem(移除成员)
    * spop(移除并返回随机元素)
* sortedset(有序集合)
    * zadd
    * zcard
    * zscore(查看元素分数)
    * zcount(返回指定区间分数的元素个数)
    * zrank(返回指定元素索引)
    * zincrby(为指定元素增加指定分数并返回增加完后的分数)
    * zrange(查看索引范围内的元素)

## Redis启动服务方式
* ./redis-server;./redis-cli(默认启动方式,端口6379)
* ./redis-server --port 6380;./redis-cli -p 6380(指定端口启动)
* ./redis-server ../redis.conf(指定配置文件启动)
* ./redis-cli -h 127.0.0.1(连接远程)
* ./redis-cli -a password(密码连接)

## Redis基础命令
* info(查看系统信息)
    * Keyspace(默认db0)
* flushdb(清除当前db)
* flushall(清除所有db)
* dbsize(当前db数量)
* save(redis持久化)

## Redis键命令
* set
* get
* hset(hash)
* keys
    * 该指令一次性返回所有匹配的key
    * 键的数量过大会使服务卡顿
    * scan
* del
* exists
* ttl(查看key剩余生存时间,单位为秒,返回-1则代表没有过期时间,-2代表不存在)
* expire(设置键的过期时间)
* type(查看值的类型)
* randomkey
* rename(重命名)
* 以nx结尾的命令多会先判断

## Redis分布式锁命令
* setnx
* set key value [EX seconds] [PX millisconds] [NX|XX]
* getset
* expire
* del

## Redis持久化
* RDB(快照)持久化：保存某个时间点的全量数据快照
    * 内存数据的全量同步，数据量大会由于I/O而严重影响性能
    * 可能会因为Redis怪掉而丢失从当前至最近一次快照期间的数据
* AOF(Append-Only-File)持久化：保存写状态
    * 记录下除了查询以外的所有变更数据库状态的指令
    * 以append的形式追加保存到AOF文件中（增量）
    * 日志重写解决AOF文件大小不断增大的问题
        * 调用fork(),创建一个子进程
        * 子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件
        * 主进程持续将新的变动同时写到内存和原来的AOF里
        * 主进程获取子进程重写AOF完成信号，往新AOF同步增量变动
        * 使用新的AOF文件替换掉旧的AOF文件
* RDB-AOF混合持久化方式(默认配置4.0之后)
* RDB和AOF优缺点
    * RDB优点：全量数据快照，文件小，恢复快
    * RDB缺点：无法保存最近一次快照之后的数据
    * AOF优点：可读性高，适合保存增量数据，数据不易丢失
    * AOF缺点：文件体积大，恢复时间长

## Redis数据的恢复  
RDB和AOF文件共存情况下的恢复流程
AOF->RDB

## 大量的key同时过期的注意事项   
集中过期，由于清除大量的key很耗时，会出现短暂的卡顿现象
* 在设置key的过期时间的时候，给每个key加上随机值
