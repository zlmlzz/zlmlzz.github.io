---
layout: post
title: MySQL
category: 数据库
tags: 监控,调优
keywords: 监控,调优
--- 
### 慢查询日志
* MySQL内置功能,可以记录执行超过指定时间的SQL语句
* 相关参数

```
log_output:日志输出地方,默认FILE(文件),设置TABLE(将日志记录到mysql.slow_log中)
    也可以同时设置,逗号隔开
long_query_time:执行时间超过该配置则记录,单位秒,可适用小数,默认10
log_queries_not_using_indexes:是否将未适用索引的SQL记录到慢查询日志中,默认OFF
log_throttle_queries_not_using_indexes:与log_queries_not_using_indexes配合使用
    限制每分钟写入的SQL数量,默认0
min_examined_row_limit:扫描行数至少达到多少记录才记录到慢查询日志,默认0
log_slow_admin_statements:是否记录管理语句,默认关闭
slow_query_log_file:指定慢查询日志文件路径,默认/var路径
log_slow_slave_statements:从数据库设置,决定是否记录在复制过程中超过long_query_time
    的SQL,如果binlog格式是row,则该参数无效,默认OFF
log_slow_extra:当log_output=FILE时,是否记录额外信息(8.0.14开始提供)
    对TABLE的结果无影响
```
* mysqldumpslow分析日志文件

### SQL性能分析
* EXPLAIN
    * id
    * select_type:查询类型
    * table:表名
    * partitions:匹配的分区
    * type:联接类型
    * possible_keys:可能的索引选择
    * key:实际选择的索引
    * key_len:索引的长度
    * ref:被引用的索引列
    * rows:估计要扫描的行
    * filtered:符合查询条件的数据百分比
    * extra:附加信息
    * 估算查询性能:`log(row_count)/log(index_block_lenght / 3 * 2 / (index_length + data_pointer_length)) + 1`
* SHOW PROFILE(简单方便,已废弃)

```
## 查看有无profile
select @@have_profiling;
select @@profiling;
## 启用
set @@profiling = 1;
set profiling_history_size = 100;
## 查看并找到id136
show profiles ;
show profile for query 136;
## 关闭
set @@profiling = 0;
```
* INFORMATION_SCHEMA_PROFILING(与profile本质一样)

```
select @@have_profiling;
select @@profiling;
set @@profiling = 1;
set profiling_history_size = 100;
show profiles ;
select state,format(duration,6) as duration 
from information_schema.PROFILING where QUERY_ID = 261 order by SEQ;
```
* PERFOMANCE_SCHEMA

```
## 设置
update performance_schema.setup_instruments
set enabled = 'YES',timed = 'YES'
where name like '%statement/%';

update performance_schema.setup_instruments
set enabled = 'YES',timed = 'YES'
where name like '%stage/%';

update performance_schema.setup_consumers
set enabled = 'YES'
where name like '%events_statements_%';

update performance_schema.setup_consumers
set enabled = 'YES'
where name like '%events_stage%';
## 查询并找到id1164
select event_id,truncate(timer_wait/1000000000000,6) as duration,sql_text
from performance_schema.events_statements_history_long 
where sql_text like '%salaries%';
## 具体信息
select event_name as stage,truncate(timer_wait/1000000000000,6) as duration
from performance_schema.events_stages_history_long 
where nesting_event_id = 1164;
```
* OPTIMIZER_TRACE

```
## 开启OPTIMIZER_TRACE功能
set optimizer_trace = 'enabled=on',end_markers_in_json=on;
## 设置要展示的条数
set optimizer_trace_offset = -30,optimizer_trace_limit =30;
## 查询
select * from information_schema.OPTIMIZER_TRACE limit 30;
```

### 常用诊断命令
* SHOW PROCESSLIST(查看当前正在运行的线程)
* SHOW STATUS(查看服务器相关信息)
* SHOW VARIABLES(查看变量)
* SHOW TABLE STATUS(查看表及视图状态)
* SHOW INDEX(查看索引信息)
* SHOW ENGINE(展示有关存储引擎的相关信息)
* SHOW MASTER STATUS(展示有关master binlog文件的相关信息)
* SHOW SLAVE STATUS(查看slave线程)

## 索引
* B+Tree
* Hash
* 空间索引(R-Tree)
* 全文索引

### B+Tree特性
* 完全匹配
* 范围匹配
* 前缀匹配
* 限制
    * 查询条件不包括最左列,无法使用索引
    * 跳过索引中的列,则无法完全使用索引
    * 查询中某个列的范围(模糊)查询,则其右边所有列都无法使用索引

### 创建索引的原则
* 建议创建索引的场景
    * select语句,频繁作为where条件的字段
    * update/delete语句的where条件
    * 需要分组,排序的字段
    * distinct使用的字段
    * 字段的值有唯一性约束
    * 对于多表查询,连接字段应创建索引,且类型要保持一致
* 不建议创建索引的场景
    * where子语句里用不到的字段
    * 表的记录非常少
    * 有大量重复数据,选择性底
    * 频繁更新的字段,要考虑索引维护开销

### 索引失效
* 索引列不独立(列不能是表达式的一部分,也不能是函数的参数)
* 使用左模糊
* 使用or查询的部分字段没有索引
* 字符条件未使用''引起来
* 不符合最左前缀原则的查询
* 索引字段建议添加NOT NULL约束
    * 单列索引无法存储null值,复合索引无法存储全为null的值
    * 查询时,采用is null条件时,不能利用到索引,只能全表扫描
* 隐式转换导致索引失效

### 长字段索引优化
* 使用前缀索引(索引选择性越高越好:索引选择性=不重复的索引值/数据表的总记录数)
* 无法做order by,group by;无法使用覆盖索引

### 单列索引VS组合索引
* SQL存在多个条件,多个单列索引会使用索引合并

### 覆盖索引
* 对于索引x,select的字段只需要从索引就能获得,而无需到表数据里获取,这样的索引为覆盖索引

### 重复索引,冗余索引,未使用索引
* 重复索引:在相同的列上按照相同的顺序创建的索引
* 冗余索引:如果已经存在索引indx(a,b),又创建了index(a),那么index(a)就是index(a,b)的冗余索引
* 未使用的索引:某个索引根本未曾使用

### JOIN优化
* JOIN算法-NLJ(Nested-Loop Join)
* JOIN算法-BNLJ(Block Nested-Loop Join)
* JOIN算法-BKA(Batched Key Access Join):5.6引入
* JOIN算法-HASH JOIN(用来代替BNLJ):8.0.18引入
* JOIN调优原则
    * 用小表驱动大表:一般无需考虑,关联查询优化器会自动选择最优的执行顺序
    * 如果有where语句,应当尽可能使用索引,并尽可能地减少外层循环的数据量
    * join字段尽量创建索引(字段类型要一致)
    * 尽量减少扫描的行数
    * 参与join的表不要太多
    * 如果被驱动表的join字段用不了索引,且内存充足,可以考虑将join buffer设置大一些

### 分页查询优化
* 覆盖索引
* 覆盖索引+join方式
* 覆盖索引+子查询
* 范围查询+limit语句
* 如果能获得起始主键值和结束主键值可以用between and
* 禁止传入过大的页码

### count优化

