---
layout: post
title: JVM常见问题
category: FAQ
keywords: JVM
---
## 常见问题
### 运行时区域
* 虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区
* 线程私有:程序计数器,Java虚拟机栈,本地方法栈
* 线程共享:Java堆,方法区

### 程序计数器
* 一块较小的内存空间,可以看作当前线程所执行字节码的行号指示器
* 字节码解释器工作时通过改变计数器的值选取下一条执行指,令分支,循环跳转,线程恢复等功能都需要依赖计数器完成
* 是唯一在虚拟机规范中没有规定内存溢出情况的区域
* 如果线程正在执行Java方法,计数器记录正在执行的虚拟机字节码指今地址,如果是本地方法,计数器值为 Undefined

### Java虚拟机栈的作用
* Java虚拟机栈来描述Java方法的内存模型
* 毎当有新线程创建时就会分配一个栈空间,线程结束后栈空间被回收,栈与线程拥有相同的生命周期
* 栈中元素用于支持虚拟机进行方法调用,每个方法在执行时都会创建一个栈帧存储方法的局部变量表,操作栈,动态链接和方法出囗等信息
* 每个方法从调用到执行完成,就是栈帧从入栈到出栈的过程

### 本地方法栈的作用
* 本地方法栈与虚拟机栈作用相似,不同的是虚拟机栈为虚拟机执行Java方法服务,本地方法栈为虚本地方法服务
* 调用本地方法时虚拟机栈保持不变,动态链接并直接调用指定本地方法

### 堆的作用
* 堆是虚拟机所管理的内存中最大的一块,被所有线程共享的,在虚拟机启动时创建
* 堆用来存放对象实例,Java里几乎所有对象实例都在堆分配内存

### 方法区的作用是什么
* 方法区用于存储虚拟机加载的类型信息,常量,静态变量,即时编译后的代码缓存等数据

### 运行时常量池的作用
* 运行时常量池是方法区的一部分,Class文件中除了有类的版本,字段,方法,接口等描述信息外
* 还有一项信息是常量池表,用于存放编译器生成的各种字面量与符号引用,这部分内容在类加载后存放到运行时常量池

### 直接内存
* 直接内存不属于运行时数据区,也不是虚拟机规范定义的内存区域,但这部分内存被频繁使用,而且可能导致内存溢出
* JDK1.4中新加入了NIO这种基于通道与缓冲区的IO,它可以使用native函数库直接分配堆外内存,通过堆里的DirectByteBuffer对象作为内存的引用进行操作.避免了在Java堆和native堆来回复制数据

### 内存溢出和内存泄漏
* 内存溢出:程序在申请内存时,没有足够的内存空间供其使用
* 内存泄漏:程序在申请内存后,无法释放已申请的内存空间,内存泄漏最终将导致内存溢出

### 堆溢出的原因
* 对象总容量触及最大堆容量

### 栈溢出原因
* 线程请求的栈深度大于虚拟机所允许的深度

### 运行时常量池溢出的原因
* JDK1.6之前可能是String.intern()方法导致溢出,JDK7后不会出现该问题,常量池被移至堆中

### 方法区溢出原因
* 运行时产生大量的类,方法区就会溢出

### 创建对象的过程
* 当JVM遇到字节码new指令时,首先检查该指令的参数能否在常量池中定位到一个类的符号引用,并检查引用代表的类是否已被加载,解析和初始化,如果没有就先执行类加载
* 在类加载检查通过后JVM将为对象分配内存
* 内存分配完成后JVM将成员变量初始化(赋0值),保证对象的实例字段可以不赋初始值就使用
* 设置对象头,包括哈希码,GC信息,锁信息,对象所属类的类元信息
* 执行init方法,初始化成员变量,执行实例化代码,调用类的构造方法,并把堆内对象的首地址赋值给引用变量

### 对象分配内存的方式有哪些
* 指针碰撞:堆内存规整,被使用过的内存放在一边,空闲的放在另一边,中间放着一个指针作为分界指示器,分配内存就是把指针向空闲方向挪动一段与对象大小相等的距离
* 空闲列表:堆内存不规整,虚拟机维护一个列表记录哪些内存可用,在分配时从列表找到一块足够大的空间划分给对象并更新列表记录

### 对象分配内存是否线程安全
* 不是线程安全的
* CAS加失败重试保证更新原子性
* 把内存分配按线程划分在不同空间

### 对象的内存布局
* 对象头:12B,包括对象标记和类型指针;对象标记存储对象自身的运行时数据,如哈希码,GC分代年龄,锁标志,偏向线程ID等(8B);类型指针是对象指向它的类型元数据的指针
* 实例数据:对象存储的有效信息
* 对齐填充:占位符

### 对象的访问方式
* 句柄:堆会划分出一块内存作为句柄池,reference中存储对象的句柄池
* 直接指针:堆中对象的内存布局有访问类型数据的相关信息,reference存储对象地址

### 如何判断对象是否是垃圾
* 引用计数:计数器为0则为垃圾
* 可达性分析:没有任何引用链到GC Roots相连则为垃圾(引用的对象,类静态属性引用的对象,常量引用的对象)

### 能够找到reference chain的对象,就一定会存活嘛
* 不一定,得看reference类型,软引用会在内存不足的时候被回收,弱引用会在GC时被回收,但没有reference chain的对象一定会被回收

### Java的引用类型
* 强引用:最常见的引用,内存回收时即使濒临内存耗尽也不会被回收
* 软引用:非必要对象,在系统即将发生内存溢出前,会将软引用关联的对象加入回收范围以获得更多的空间
* 弱引用:非必要对象,当垃圾收集器开始工作时无论当前内存是否足够都会回收
* 虚引用:定义完成后无法通过该引用获取对象,唯一的目的就是为了能在对象被回收时收到一个系统通知

### 有哪些GC算法
* 标记-清除
* 标记-复制
* 标记-整理

### 垃圾收集器
* Serial,复制,单线程
* ParNew,Serial多线程版本
* Parallel Scavenge,复制,多线程,可控吞吐量(CUP处理用户代码/CPU消耗总时间)
* CMS,标记-清除,以获取最短回收停顿时间为目标
* G1,处理回收价值最大的Region

### 内存分配与回收策略
* 对象优先在Eden区分配
* 大对象直接进入老年代
* 长期存活对象进入老年代
* 动态对象年龄判定:如果Survivor中相同年龄的所有对象大小的总和大于Survivor的一半,年龄不小于该年龄的对象就可以直接进入老年代
* 空间分配单保

### JVM工具
* jps:虚拟机进程状况工具
* jstat:虚拟机统计信息监视工具
* jinfo:Java配置信息工具
* jmap:Java内存映像工具
* jhat:虚拟机堆转储快照分析工具
* jstack:Java堆栈跟踪工具

### 如何查看JVM系统默认值
* 使用`-XX:+PringFlagsFinal`

### JVM常用配置参数
* -Xms:初始化大小内存,默认为物理内存1/64
* -Xmx:最大分配内存,默认为物理内存1/4
* -Xss:设置单个线程栈大小,一般默认为512k~1024k
* -Xmn:设置年轻代大小,一般不需要改动

### 配置垃圾收集器
* 内存大小,每个区域设置一个上限;堆设置为2/3,超过8G的堆优先使用G1
* 根据老年代对象提升速度,来调整年轻代和老年代之间的比例

### 查看服务器默认的垃圾回收器
* 

### Java程序是怎样运行的
* 首先通过Javac编译器将.java转为JVM可加载的.class字节码文件
* 之后通过即时编译器JIT把字节码文件编译成本地字节码

### 类加载是什么
* JVM把描述类的数据从class文件加载到内存,并对数据进行校验,解析和初始化,最终形成可以被虚拟机直接使用的Java类型

### 类加载过程
* 加载:通过类的全名获取定义类的二进制字节流;将字节流所代表的静态存储结构转化为方法区的运行时数据;在内存中生成对应该类的class实例,作为方法区这个类的数据访问入口
* 验证:确保class文件的字节流符合约束,主要包括文件格式验证,元数据验证,字节码验证,符号引用验证
* 准备:为类静态变量分配内存并设置0值,包括类变量,不包括实例变量
* 解析:将常量池内的符号引用替换为直接引用
* 初始化:JVM开始执行类中编写的代码

### 有哪些类加载器
* 启动类加载器
* 平台类加载器
* 应用类加载器

### 双亲委派模型
* 一个类加载器收到类加载请求,不会自己去尝试加载,而将请求委派给父类加载器,只有当父类加载器无法加载,子加载器才会尝试

### 如何判断两个类是否相等
* 来源同一个class文件
* 加载器相同
